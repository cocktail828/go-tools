package caller

import (
	"runtime"
)

type callerInfo struct {
	File string
	Line int
	Name string
	PC   uintptr
}

func backtrace(ignores ...string) []callerInfo {
	ignores = append(ignores, "github.com/cocktail828/go-tools/z/caller.backtrace")
	callers := []callerInfo{}

	for i := 0; ; i++ {
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			// The breaks below failed to terminate the loop, and we ran off the
			// end of the call stack.
			break
		}

		// This is a huge edge case, but it will panic if this is the case, see #180
		if file == "<autogenerated>" {
			break
		}

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}

		name := f.Name()

		// should pass-through
		if passthrough := func() bool {
			for _, ignore := range ignores {
				if name == ignore {
					return false
				}
			}
			return true
		}(); !passthrough {
			continue
		}

		// testing.tRunner is the standard library function that calls
		// tests. Subtests are called directly by tRunner, without going through
		// the Test/Benchmark/Example function that contains the t.Run calls, so
		// with subtests we should break when we hit tRunner, without adding it
		// to the list of callers.
		if name == "testing.tRunner" {
			break
		}

		callers = append(callers, callerInfo{
			File: file,
			Line: line,
			Name: name,
			PC:   pc,
		})
	}

	return callers
}

// Backtrace returns an array of strings containing the file and line number
// of each stack frame leading from the current test to the assert call that
// failed.
func Backtrace() []callerInfo {
	return backtrace("github.com/cocktail828/go-tools/z/caller.Backtrace")
}

func Last() callerInfo {
	cis := backtrace("github.com/cocktail828/go-tools/z/caller.Last")
	if len(cis) > 0 {
		return cis[0]
	}
	return callerInfo{}
}
